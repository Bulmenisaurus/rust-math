"""
High lever overview:

There are only a finite amount of results of 2^x mod 100 (namely <= 100, but usually less than this).
Once some 2^x mod 100 repeats, the loop continues forever. For example for 2^x mod 5, this looks like

1 -> 2 -> 4 -> 3
↑              │
└──────────────┘ 

So, we can precompute these modular lookup tables which in this case would look like

ARR = [
    true,  // 1 ✓
    true,  // 2 ✓
    true,  // 4 ✓
    false, // 3 ✗
]

Going back to our case, we could computer this for 10 items and simply check ARR[n % 10].
If the result is true, that means that the last two digits are powers of two. Otherwise, they aren't.

There is also another edge case that needs to be considered, and it's that some results are never returned to again.
For example, in the case of mod 100 after a result of 52, 2 * 52 mod 100 = 4. This means that the results of 1 and 2 (mod 100)
are never reached again. In this case, we need to discard the first two values of our lookup table and shift all of the indices
down by two when querying.

"""


def main():
    # runs through powers of two, just looking at the last N digits until it finds a repeat

    n_digits = 3
    encountered: list[int] = []
    lookup_array: list[int] = []

    i = 0
    current_power_two = 1
    loop_pow_value = 0
    loop_pow_idx = 0

    while True:

        if current_power_two in encountered:
            loop_pow_value = current_power_two
            loop_pow_idx = i
            break
        else:
            encountered.append(current_power_two)
            lookup_array.append(current_power_two)

            i += 1
            current_power_two *= 2
            current_power_two %= 10**n_digits

    print(lookup_array)

    skip_loop_idx = lookup_array.index(loop_pow_value)

    lookup_array = lookup_array[skip_loop_idx:]

    newline = '\n'
    rust_code_table = [
        f"    {'true, ' if only_pow_2(str(line).rjust(3, '0')) else 'false,'} // {line}" for line in lookup_array]
    rust_code_lookup = f"const LOOKUP_ARRAY: [bool; {len(lookup_array)}] = [\n{newline.join(rust_code_table)}\n];"

    rust_code_function = f"""
fn check_pow2_mod_100(n: u64) -> bool {{
    // values smaller than this will never be returned to again
    if n <= {skip_loop_idx} {{
        return false;
    }}

    let n: u64 = (n - {skip_loop_idx}) % {len(lookup_array)};
    let n: usize = usize::try_from(n).unwrap();

    LOOKUP_ARRAY[n]
}}
"""

    print("// Warning: code autogenerated by ./src/generatelookup.py since I don't know how to use macros yet\n" +
          rust_code_lookup + "\n" + rust_code_function)


def only_pow_2(string: str):
    return all([x in list("1248") for x in string])


if __name__ == '__main__':
    main()
