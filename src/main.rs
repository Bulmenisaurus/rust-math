use std::io::{stdout, Write};

const DIGITS_LEN: usize = 25;

fn main() {
    let mut digits = [0; DIGITS_LEN];
    digits[0] = 1;
    let mut i: u64 = 0;
    println!("checking last {} digits", DIGITS_LEN);

    let mut output = stdout();

    loop {
        if check_pow2_mod_100(i) && is_only_pow2(digits) {
            println!("\nfound 2^{}", i);
            return;
        }

        if i % 1_000_000_000 == 0 {
            print!("\rScanned {} billion", i / 1_000_000_000);
            output.flush().unwrap();
        }

        digits = mul_2_digits(digits);
        i += 1;
    }
}

// Warning: code autogenerated by ./src/generatelookup.py since I don't know how to use macros yet
const LOOKUP_ARRAY: [bool; 20] = [
    true,  // 4
    true,  // 8
    false, // 16
    false, // 32
    false, // 64
    true,  // 28
    false, // 56
    true,  // 12
    true,  // 24
    true,  // 48
    false, // 96
    false, // 92
    true,  // 84
    false, // 68
    false, // 36
    false, // 72
    true,  // 44
    true,  // 88
    false, // 76
    false, // 52
];

fn check_pow2_mod_100(n: u64) -> bool {
    // values smaller than this will never be returned to again
    if n <= 2 {
        return false;
    }

    let n: u64 = (n - 2) % 20;
    let n: usize = usize::try_from(n).unwrap();

    LOOKUP_ARRAY[n]
}

// digits are stored back to front, least significant in the front
fn mul_2_digits(digits: [u8; DIGITS_LEN]) -> [u8; DIGITS_LEN] {
    let mut new_digits: [u8; DIGITS_LEN] = [0; DIGITS_LEN];

    digits.iter().enumerate().for_each(|(i, &item)| {
        // guaranteed to fit in, as item <= 9 and 2*item <= 18 < 127
        let new_digit_value = item * 2;
        let digit = new_digit_value % 10;
        let carry = (new_digit_value - digit) / 10;

        new_digits[i] += digit;

        // if currently at the DIGITS_LENth digit, don't set next (as it is out of bounds)
        // otherwise, set the next digit to the carry otherwise
        if i + 1 != DIGITS_LEN {
            new_digits[i + 1] = carry;
        }
    });

    new_digits
}

fn is_only_pow2(digits: [u8; DIGITS_LEN]) -> bool {
    digits.iter().all(|&m| m == 1 || m == 2 || m == 4 || m == 8)
}
